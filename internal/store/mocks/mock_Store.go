// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	model "github.com/sells-group/research-cli/internal/model"
	mock "github.com/stretchr/testify/mock"

	resilience "github.com/sells-group/research-cli/internal/resilience"

	store "github.com/sells-group/research-cli/internal/store"

	time "time"
)

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// Close provides a mock function with no fields
func (_m *MockStore) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockStore_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockStore_Expecter) Close() *MockStore_Close_Call {
	return &MockStore_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockStore_Close_Call) Run(run func()) *MockStore_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_Close_Call) Return(_a0 error) *MockStore_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_Close_Call) RunAndReturn(run func() error) *MockStore_Close_Call {
	_c.Call.Return(run)
	return _c
}

// CompletePhase provides a mock function with given fields: ctx, phaseID, result
func (_m *MockStore) CompletePhase(ctx context.Context, phaseID string, result *model.PhaseResult) error {
	ret := _m.Called(ctx, phaseID, result)

	if len(ret) == 0 {
		panic("no return value specified for CompletePhase")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.PhaseResult) error); ok {
		r0 = rf(ctx, phaseID, result)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_CompletePhase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompletePhase'
type MockStore_CompletePhase_Call struct {
	*mock.Call
}

// CompletePhase is a helper method to define mock.On call
//   - ctx context.Context
//   - phaseID string
//   - result *model.PhaseResult
func (_e *MockStore_Expecter) CompletePhase(ctx interface{}, phaseID interface{}, result interface{}) *MockStore_CompletePhase_Call {
	return &MockStore_CompletePhase_Call{Call: _e.mock.On("CompletePhase", ctx, phaseID, result)}
}

func (_c *MockStore_CompletePhase_Call) Run(run func(ctx context.Context, phaseID string, result *model.PhaseResult)) *MockStore_CompletePhase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*model.PhaseResult))
	})
	return _c
}

func (_c *MockStore_CompletePhase_Call) Return(_a0 error) *MockStore_CompletePhase_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_CompletePhase_Call) RunAndReturn(run func(context.Context, string, *model.PhaseResult) error) *MockStore_CompletePhase_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePhase provides a mock function with given fields: ctx, runID, name
func (_m *MockStore) CreatePhase(ctx context.Context, runID string, name string) (*model.RunPhase, error) {
	ret := _m.Called(ctx, runID, name)

	if len(ret) == 0 {
		panic("no return value specified for CreatePhase")
	}

	var r0 *model.RunPhase
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*model.RunPhase, error)); ok {
		return rf(ctx, runID, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *model.RunPhase); ok {
		r0 = rf(ctx, runID, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.RunPhase)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, runID, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CreatePhase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePhase'
type MockStore_CreatePhase_Call struct {
	*mock.Call
}

// CreatePhase is a helper method to define mock.On call
//   - ctx context.Context
//   - runID string
//   - name string
func (_e *MockStore_Expecter) CreatePhase(ctx interface{}, runID interface{}, name interface{}) *MockStore_CreatePhase_Call {
	return &MockStore_CreatePhase_Call{Call: _e.mock.On("CreatePhase", ctx, runID, name)}
}

func (_c *MockStore_CreatePhase_Call) Run(run func(ctx context.Context, runID string, name string)) *MockStore_CreatePhase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockStore_CreatePhase_Call) Return(_a0 *model.RunPhase, _a1 error) *MockStore_CreatePhase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CreatePhase_Call) RunAndReturn(run func(context.Context, string, string) (*model.RunPhase, error)) *MockStore_CreatePhase_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRun provides a mock function with given fields: ctx, company
func (_m *MockStore) CreateRun(ctx context.Context, company model.Company) (*model.Run, error) {
	ret := _m.Called(ctx, company)

	if len(ret) == 0 {
		panic("no return value specified for CreateRun")
	}

	var r0 *model.Run
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Company) (*model.Run, error)); ok {
		return rf(ctx, company)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.Company) *model.Run); ok {
		r0 = rf(ctx, company)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Run)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.Company) error); ok {
		r1 = rf(ctx, company)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CreateRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRun'
type MockStore_CreateRun_Call struct {
	*mock.Call
}

// CreateRun is a helper method to define mock.On call
//   - ctx context.Context
//   - company model.Company
func (_e *MockStore_Expecter) CreateRun(ctx interface{}, company interface{}) *MockStore_CreateRun_Call {
	return &MockStore_CreateRun_Call{Call: _e.mock.On("CreateRun", ctx, company)}
}

func (_c *MockStore_CreateRun_Call) Run(run func(ctx context.Context, company model.Company)) *MockStore_CreateRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Company))
	})
	return _c
}

func (_c *MockStore_CreateRun_Call) Return(_a0 *model.Run, _a1 error) *MockStore_CreateRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CreateRun_Call) RunAndReturn(run func(context.Context, model.Company) (*model.Run, error)) *MockStore_CreateRun_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteExpiredCrawls provides a mock function with given fields: ctx
func (_m *MockStore) DeleteExpiredCrawls(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExpiredCrawls")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_DeleteExpiredCrawls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteExpiredCrawls'
type MockStore_DeleteExpiredCrawls_Call struct {
	*mock.Call
}

// DeleteExpiredCrawls is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) DeleteExpiredCrawls(ctx interface{}) *MockStore_DeleteExpiredCrawls_Call {
	return &MockStore_DeleteExpiredCrawls_Call{Call: _e.mock.On("DeleteExpiredCrawls", ctx)}
}

func (_c *MockStore_DeleteExpiredCrawls_Call) Run(run func(ctx context.Context)) *MockStore_DeleteExpiredCrawls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_DeleteExpiredCrawls_Call) Return(_a0 int, _a1 error) *MockStore_DeleteExpiredCrawls_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_DeleteExpiredCrawls_Call) RunAndReturn(run func(context.Context) (int, error)) *MockStore_DeleteExpiredCrawls_Call {
	_c.Call.Return(run)
	return _c
}

// FailRun provides a mock function with given fields: ctx, runID, runErr
func (_m *MockStore) FailRun(ctx context.Context, runID string, runErr *model.RunError) error {
	ret := _m.Called(ctx, runID, runErr)

	if len(ret) == 0 {
		panic("no return value specified for FailRun")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.RunError) error); ok {
		r0 = rf(ctx, runID, runErr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_FailRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FailRun'
type MockStore_FailRun_Call struct {
	*mock.Call
}

// FailRun is a helper method to define mock.On call
//   - ctx context.Context
//   - runID string
//   - runErr *model.RunError
func (_e *MockStore_Expecter) FailRun(ctx interface{}, runID interface{}, runErr interface{}) *MockStore_FailRun_Call {
	return &MockStore_FailRun_Call{Call: _e.mock.On("FailRun", ctx, runID, runErr)}
}

func (_c *MockStore_FailRun_Call) Run(run func(ctx context.Context, runID string, runErr *model.RunError)) *MockStore_FailRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*model.RunError))
	})
	return _c
}

func (_c *MockStore_FailRun_Call) Return(_a0 error) *MockStore_FailRun_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_FailRun_Call) RunAndReturn(run func(context.Context, string, *model.RunError) error) *MockStore_FailRun_Call {
	_c.Call.Return(run)
	return _c
}

// GetCachedCrawl provides a mock function with given fields: ctx, companyURL
func (_m *MockStore) GetCachedCrawl(ctx context.Context, companyURL string) (*model.CrawlCache, error) {
	ret := _m.Called(ctx, companyURL)

	if len(ret) == 0 {
		panic("no return value specified for GetCachedCrawl")
	}

	var r0 *model.CrawlCache
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.CrawlCache, error)); ok {
		return rf(ctx, companyURL)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.CrawlCache); ok {
		r0 = rf(ctx, companyURL)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CrawlCache)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, companyURL)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetCachedCrawl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCachedCrawl'
type MockStore_GetCachedCrawl_Call struct {
	*mock.Call
}

// GetCachedCrawl is a helper method to define mock.On call
//   - ctx context.Context
//   - companyURL string
func (_e *MockStore_Expecter) GetCachedCrawl(ctx interface{}, companyURL interface{}) *MockStore_GetCachedCrawl_Call {
	return &MockStore_GetCachedCrawl_Call{Call: _e.mock.On("GetCachedCrawl", ctx, companyURL)}
}

func (_c *MockStore_GetCachedCrawl_Call) Run(run func(ctx context.Context, companyURL string)) *MockStore_GetCachedCrawl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_GetCachedCrawl_Call) Return(_a0 *model.CrawlCache, _a1 error) *MockStore_GetCachedCrawl_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetCachedCrawl_Call) RunAndReturn(run func(context.Context, string) (*model.CrawlCache, error)) *MockStore_GetCachedCrawl_Call {
	_c.Call.Return(run)
	return _c
}

// GetRun provides a mock function with given fields: ctx, runID
func (_m *MockStore) GetRun(ctx context.Context, runID string) (*model.Run, error) {
	ret := _m.Called(ctx, runID)

	if len(ret) == 0 {
		panic("no return value specified for GetRun")
	}

	var r0 *model.Run
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Run, error)); ok {
		return rf(ctx, runID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Run); ok {
		r0 = rf(ctx, runID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Run)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, runID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRun'
type MockStore_GetRun_Call struct {
	*mock.Call
}

// GetRun is a helper method to define mock.On call
//   - ctx context.Context
//   - runID string
func (_e *MockStore_Expecter) GetRun(ctx interface{}, runID interface{}) *MockStore_GetRun_Call {
	return &MockStore_GetRun_Call{Call: _e.mock.On("GetRun", ctx, runID)}
}

func (_c *MockStore_GetRun_Call) Run(run func(ctx context.Context, runID string)) *MockStore_GetRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_GetRun_Call) Return(_a0 *model.Run, _a1 error) *MockStore_GetRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetRun_Call) RunAndReturn(run func(context.Context, string) (*model.Run, error)) *MockStore_GetRun_Call {
	_c.Call.Return(run)
	return _c
}

// ListRuns provides a mock function with given fields: ctx, filter
func (_m *MockStore) ListRuns(ctx context.Context, filter store.RunFilter) ([]model.Run, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for ListRuns")
	}

	var r0 []model.Run
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.RunFilter) ([]model.Run, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.RunFilter) []model.Run); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Run)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.RunFilter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_ListRuns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRuns'
type MockStore_ListRuns_Call struct {
	*mock.Call
}

// ListRuns is a helper method to define mock.On call
//   - ctx context.Context
//   - filter store.RunFilter
func (_e *MockStore_Expecter) ListRuns(ctx interface{}, filter interface{}) *MockStore_ListRuns_Call {
	return &MockStore_ListRuns_Call{Call: _e.mock.On("ListRuns", ctx, filter)}
}

func (_c *MockStore_ListRuns_Call) Run(run func(ctx context.Context, filter store.RunFilter)) *MockStore_ListRuns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(store.RunFilter))
	})
	return _c
}

func (_c *MockStore_ListRuns_Call) Return(_a0 []model.Run, _a1 error) *MockStore_ListRuns_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_ListRuns_Call) RunAndReturn(run func(context.Context, store.RunFilter) ([]model.Run, error)) *MockStore_ListRuns_Call {
	_c.Call.Return(run)
	return _c
}

// Migrate provides a mock function with given fields: ctx
func (_m *MockStore) Migrate(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Migrate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_Migrate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Migrate'
type MockStore_Migrate_Call struct {
	*mock.Call
}

// Migrate is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) Migrate(ctx interface{}) *MockStore_Migrate_Call {
	return &MockStore_Migrate_Call{Call: _e.mock.On("Migrate", ctx)}
}

func (_c *MockStore_Migrate_Call) Run(run func(ctx context.Context)) *MockStore_Migrate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_Migrate_Call) Return(_a0 error) *MockStore_Migrate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_Migrate_Call) RunAndReturn(run func(context.Context) error) *MockStore_Migrate_Call {
	_c.Call.Return(run)
	return _c
}

// SetCachedCrawl provides a mock function with given fields: ctx, companyURL, pages, ttl
func (_m *MockStore) SetCachedCrawl(ctx context.Context, companyURL string, pages []model.CrawledPage, ttl time.Duration) error {
	ret := _m.Called(ctx, companyURL, pages, ttl)

	if len(ret) == 0 {
		panic("no return value specified for SetCachedCrawl")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []model.CrawledPage, time.Duration) error); ok {
		r0 = rf(ctx, companyURL, pages, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_SetCachedCrawl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetCachedCrawl'
type MockStore_SetCachedCrawl_Call struct {
	*mock.Call
}

// SetCachedCrawl is a helper method to define mock.On call
//   - ctx context.Context
//   - companyURL string
//   - pages []model.CrawledPage
//   - ttl time.Duration
func (_e *MockStore_Expecter) SetCachedCrawl(ctx interface{}, companyURL interface{}, pages interface{}, ttl interface{}) *MockStore_SetCachedCrawl_Call {
	return &MockStore_SetCachedCrawl_Call{Call: _e.mock.On("SetCachedCrawl", ctx, companyURL, pages, ttl)}
}

func (_c *MockStore_SetCachedCrawl_Call) Run(run func(ctx context.Context, companyURL string, pages []model.CrawledPage, ttl time.Duration)) *MockStore_SetCachedCrawl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]model.CrawledPage), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockStore_SetCachedCrawl_Call) Return(_a0 error) *MockStore_SetCachedCrawl_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_SetCachedCrawl_Call) RunAndReturn(run func(context.Context, string, []model.CrawledPage, time.Duration) error) *MockStore_SetCachedCrawl_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRunResult provides a mock function with given fields: ctx, runID, result
func (_m *MockStore) UpdateRunResult(ctx context.Context, runID string, result *model.RunResult) error {
	ret := _m.Called(ctx, runID, result)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRunResult")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.RunResult) error); ok {
		r0 = rf(ctx, runID, result)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_UpdateRunResult_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRunResult'
type MockStore_UpdateRunResult_Call struct {
	*mock.Call
}

// UpdateRunResult is a helper method to define mock.On call
//   - ctx context.Context
//   - runID string
//   - result *model.RunResult
func (_e *MockStore_Expecter) UpdateRunResult(ctx interface{}, runID interface{}, result interface{}) *MockStore_UpdateRunResult_Call {
	return &MockStore_UpdateRunResult_Call{Call: _e.mock.On("UpdateRunResult", ctx, runID, result)}
}

func (_c *MockStore_UpdateRunResult_Call) Run(run func(ctx context.Context, runID string, result *model.RunResult)) *MockStore_UpdateRunResult_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*model.RunResult))
	})
	return _c
}

func (_c *MockStore_UpdateRunResult_Call) Return(_a0 error) *MockStore_UpdateRunResult_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_UpdateRunResult_Call) RunAndReturn(run func(context.Context, string, *model.RunResult) error) *MockStore_UpdateRunResult_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRunStatus provides a mock function with given fields: ctx, runID, status
func (_m *MockStore) UpdateRunStatus(ctx context.Context, runID string, status model.RunStatus) error {
	ret := _m.Called(ctx, runID, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRunStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, model.RunStatus) error); ok {
		r0 = rf(ctx, runID, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_UpdateRunStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRunStatus'
type MockStore_UpdateRunStatus_Call struct {
	*mock.Call
}

// UpdateRunStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - runID string
//   - status model.RunStatus
func (_e *MockStore_Expecter) UpdateRunStatus(ctx interface{}, runID interface{}, status interface{}) *MockStore_UpdateRunStatus_Call {
	return &MockStore_UpdateRunStatus_Call{Call: _e.mock.On("UpdateRunStatus", ctx, runID, status)}
}

func (_c *MockStore_UpdateRunStatus_Call) Run(run func(ctx context.Context, runID string, status model.RunStatus)) *MockStore_UpdateRunStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(model.RunStatus))
	})
	return _c
}

func (_c *MockStore_UpdateRunStatus_Call) Return(_a0 error) *MockStore_UpdateRunStatus_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_UpdateRunStatus_Call) RunAndReturn(run func(context.Context, string, model.RunStatus) error) *MockStore_UpdateRunStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetCachedLinkedIn provides a mock function with given fields: ctx, domain
func (_m *MockStore) GetCachedLinkedIn(ctx context.Context, domain string) ([]byte, error) {
	ret := _m.Called(ctx, domain)

	if len(ret) == 0 {
		panic("no return value specified for GetCachedLinkedIn")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]byte, error)); ok {
		return rf(ctx, domain)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []byte); ok {
		r0 = rf(ctx, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetCachedLinkedIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCachedLinkedIn'
type MockStore_GetCachedLinkedIn_Call struct {
	*mock.Call
}

// GetCachedLinkedIn is a helper method to define mock.On call
//   - ctx context.Context
//   - domain string
func (_e *MockStore_Expecter) GetCachedLinkedIn(ctx interface{}, domain interface{}) *MockStore_GetCachedLinkedIn_Call {
	return &MockStore_GetCachedLinkedIn_Call{Call: _e.mock.On("GetCachedLinkedIn", ctx, domain)}
}

func (_c *MockStore_GetCachedLinkedIn_Call) Run(run func(ctx context.Context, domain string)) *MockStore_GetCachedLinkedIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_GetCachedLinkedIn_Call) Return(_a0 []byte, _a1 error) *MockStore_GetCachedLinkedIn_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetCachedLinkedIn_Call) RunAndReturn(run func(context.Context, string) ([]byte, error)) *MockStore_GetCachedLinkedIn_Call {
	_c.Call.Return(run)
	return _c
}

// SetCachedLinkedIn provides a mock function with given fields: ctx, domain, data, ttl
func (_m *MockStore) SetCachedLinkedIn(ctx context.Context, domain string, data []byte, ttl time.Duration) error {
	ret := _m.Called(ctx, domain, data, ttl)

	if len(ret) == 0 {
		panic("no return value specified for SetCachedLinkedIn")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, time.Duration) error); ok {
		r0 = rf(ctx, domain, data, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_SetCachedLinkedIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetCachedLinkedIn'
type MockStore_SetCachedLinkedIn_Call struct {
	*mock.Call
}

// SetCachedLinkedIn is a helper method to define mock.On call
//   - ctx context.Context
//   - domain string
//   - data []byte
//   - ttl time.Duration
func (_e *MockStore_Expecter) SetCachedLinkedIn(ctx interface{}, domain interface{}, data interface{}, ttl interface{}) *MockStore_SetCachedLinkedIn_Call {
	return &MockStore_SetCachedLinkedIn_Call{Call: _e.mock.On("SetCachedLinkedIn", ctx, domain, data, ttl)}
}

func (_c *MockStore_SetCachedLinkedIn_Call) Run(run func(ctx context.Context, domain string, data []byte, ttl time.Duration)) *MockStore_SetCachedLinkedIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]byte), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockStore_SetCachedLinkedIn_Call) Return(_a0 error) *MockStore_SetCachedLinkedIn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_SetCachedLinkedIn_Call) RunAndReturn(run func(context.Context, string, []byte, time.Duration) error) *MockStore_SetCachedLinkedIn_Call {
	_c.Call.Return(run)
	return _c
}

// GetCachedScrape provides a mock function with given fields: ctx, urlHash
func (_m *MockStore) GetCachedScrape(ctx context.Context, urlHash string) ([]byte, error) {
	ret := _m.Called(ctx, urlHash)

	if len(ret) == 0 {
		panic("no return value specified for GetCachedScrape")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]byte, error)); ok {
		return rf(ctx, urlHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []byte); ok {
		r0 = rf(ctx, urlHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, urlHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetCachedScrape provides a mock function with given fields: ctx, urlHash, content, ttl
func (_m *MockStore) SetCachedScrape(ctx context.Context, urlHash string, content []byte, ttl time.Duration) error {
	ret := _m.Called(ctx, urlHash, content, ttl)

	if len(ret) == 0 {
		panic("no return value specified for SetCachedScrape")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, time.Duration) error); ok {
		r0 = rf(ctx, urlHash, content, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetHighConfidenceAnswers provides a mock function with given fields: ctx, companyURL, minConfidence
func (_m *MockStore) GetHighConfidenceAnswers(ctx context.Context, companyURL string, minConfidence float64) ([]model.ExtractionAnswer, error) {
	ret := _m.Called(ctx, companyURL, minConfidence)

	if len(ret) == 0 {
		panic("no return value specified for GetHighConfidenceAnswers")
	}

	var r0 []model.ExtractionAnswer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) ([]model.ExtractionAnswer, error)); ok {
		return rf(ctx, companyURL, minConfidence)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) []model.ExtractionAnswer); ok {
		r0 = rf(ctx, companyURL, minConfidence)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.ExtractionAnswer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, float64) error); ok {
		r1 = rf(ctx, companyURL, minConfidence)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveCheckpoint provides a mock function with given fields: ctx, companyID, phase, data
func (_m *MockStore) SaveCheckpoint(ctx context.Context, companyID string, phase string, data []byte) error {
	ret := _m.Called(ctx, companyID, phase, data)

	if len(ret) == 0 {
		panic("no return value specified for SaveCheckpoint")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []byte) error); ok {
		r0 = rf(ctx, companyID, phase, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LoadCheckpoint provides a mock function with given fields: ctx, companyID
func (_m *MockStore) LoadCheckpoint(ctx context.Context, companyID string) (*model.Checkpoint, error) {
	ret := _m.Called(ctx, companyID)

	if len(ret) == 0 {
		panic("no return value specified for LoadCheckpoint")
	}

	var r0 *model.Checkpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Checkpoint, error)); ok {
		return rf(ctx, companyID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Checkpoint); ok {
		r0 = rf(ctx, companyID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Checkpoint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, companyID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCheckpoint provides a mock function with given fields: ctx, companyID
func (_m *MockStore) DeleteCheckpoint(ctx context.Context, companyID string) error {
	ret := _m.Called(ctx, companyID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCheckpoint")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, companyID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Ping provides a mock function with given fields: ctx
func (_m *MockStore) Ping(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteExpiredLinkedIn provides a mock function with given fields: ctx
func (_m *MockStore) DeleteExpiredLinkedIn(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExpiredLinkedIn")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteExpiredScrapes provides a mock function with given fields: ctx
func (_m *MockStore) DeleteExpiredScrapes(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExpiredScrapes")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountDLQ provides a mock function with given fields: ctx
func (_m *MockStore) CountDLQ(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountDLQ")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CountDLQ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountDLQ'
type MockStore_CountDLQ_Call struct {
	*mock.Call
}

// CountDLQ is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) CountDLQ(ctx interface{}) *MockStore_CountDLQ_Call {
	return &MockStore_CountDLQ_Call{Call: _e.mock.On("CountDLQ", ctx)}
}

func (_c *MockStore_CountDLQ_Call) Run(run func(ctx context.Context)) *MockStore_CountDLQ_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_CountDLQ_Call) Return(_a0 int, _a1 error) *MockStore_CountDLQ_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CountDLQ_Call) RunAndReturn(run func(context.Context) (int, error)) *MockStore_CountDLQ_Call {
	_c.Call.Return(run)
	return _c
}

// DequeueDLQ provides a mock function with given fields: ctx, filter
func (_m *MockStore) DequeueDLQ(ctx context.Context, filter resilience.DLQFilter) ([]resilience.DLQEntry, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for DequeueDLQ")
	}

	var r0 []resilience.DLQEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, resilience.DLQFilter) ([]resilience.DLQEntry, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, resilience.DLQFilter) []resilience.DLQEntry); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]resilience.DLQEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, resilience.DLQFilter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_DequeueDLQ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DequeueDLQ'
type MockStore_DequeueDLQ_Call struct {
	*mock.Call
}

// DequeueDLQ is a helper method to define mock.On call
//   - ctx context.Context
//   - filter resilience.DLQFilter
func (_e *MockStore_Expecter) DequeueDLQ(ctx interface{}, filter interface{}) *MockStore_DequeueDLQ_Call {
	return &MockStore_DequeueDLQ_Call{Call: _e.mock.On("DequeueDLQ", ctx, filter)}
}

func (_c *MockStore_DequeueDLQ_Call) Run(run func(ctx context.Context, filter resilience.DLQFilter)) *MockStore_DequeueDLQ_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(resilience.DLQFilter))
	})
	return _c
}

func (_c *MockStore_DequeueDLQ_Call) Return(_a0 []resilience.DLQEntry, _a1 error) *MockStore_DequeueDLQ_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_DequeueDLQ_Call) RunAndReturn(run func(context.Context, resilience.DLQFilter) ([]resilience.DLQEntry, error)) *MockStore_DequeueDLQ_Call {
	_c.Call.Return(run)
	return _c
}

// EnqueueDLQ provides a mock function with given fields: ctx, entry
func (_m *MockStore) EnqueueDLQ(ctx context.Context, entry resilience.DLQEntry) error {
	ret := _m.Called(ctx, entry)

	if len(ret) == 0 {
		panic("no return value specified for EnqueueDLQ")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, resilience.DLQEntry) error); ok {
		r0 = rf(ctx, entry)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_EnqueueDLQ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnqueueDLQ'
type MockStore_EnqueueDLQ_Call struct {
	*mock.Call
}

// EnqueueDLQ is a helper method to define mock.On call
//   - ctx context.Context
//   - entry resilience.DLQEntry
func (_e *MockStore_Expecter) EnqueueDLQ(ctx interface{}, entry interface{}) *MockStore_EnqueueDLQ_Call {
	return &MockStore_EnqueueDLQ_Call{Call: _e.mock.On("EnqueueDLQ", ctx, entry)}
}

func (_c *MockStore_EnqueueDLQ_Call) Run(run func(ctx context.Context, entry resilience.DLQEntry)) *MockStore_EnqueueDLQ_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(resilience.DLQEntry))
	})
	return _c
}

func (_c *MockStore_EnqueueDLQ_Call) Return(_a0 error) *MockStore_EnqueueDLQ_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_EnqueueDLQ_Call) RunAndReturn(run func(context.Context, resilience.DLQEntry) error) *MockStore_EnqueueDLQ_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementDLQRetry provides a mock function with given fields: ctx, id, nextRetryAt, lastErr
func (_m *MockStore) IncrementDLQRetry(ctx context.Context, id string, nextRetryAt time.Time, lastErr string) error {
	ret := _m.Called(ctx, id, nextRetryAt, lastErr)

	if len(ret) == 0 {
		panic("no return value specified for IncrementDLQRetry")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, string) error); ok {
		r0 = rf(ctx, id, nextRetryAt, lastErr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_IncrementDLQRetry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementDLQRetry'
type MockStore_IncrementDLQRetry_Call struct {
	*mock.Call
}

// IncrementDLQRetry is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - nextRetryAt time.Time
//   - lastErr string
func (_e *MockStore_Expecter) IncrementDLQRetry(ctx interface{}, id interface{}, nextRetryAt interface{}, lastErr interface{}) *MockStore_IncrementDLQRetry_Call {
	return &MockStore_IncrementDLQRetry_Call{Call: _e.mock.On("IncrementDLQRetry", ctx, id, nextRetryAt, lastErr)}
}

func (_c *MockStore_IncrementDLQRetry_Call) Run(run func(ctx context.Context, id string, nextRetryAt time.Time, lastErr string)) *MockStore_IncrementDLQRetry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time), args[3].(string))
	})
	return _c
}

func (_c *MockStore_IncrementDLQRetry_Call) Return(_a0 error) *MockStore_IncrementDLQRetry_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_IncrementDLQRetry_Call) RunAndReturn(run func(context.Context, string, time.Time, string) error) *MockStore_IncrementDLQRetry_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveDLQ provides a mock function with given fields: ctx, id
func (_m *MockStore) RemoveDLQ(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveDLQ")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_RemoveDLQ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveDLQ'
type MockStore_RemoveDLQ_Call struct {
	*mock.Call
}

// RemoveDLQ is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStore_Expecter) RemoveDLQ(ctx interface{}, id interface{}) *MockStore_RemoveDLQ_Call {
	return &MockStore_RemoveDLQ_Call{Call: _e.mock.On("RemoveDLQ", ctx, id)}
}

func (_c *MockStore_RemoveDLQ_Call) Run(run func(ctx context.Context, id string)) *MockStore_RemoveDLQ_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_RemoveDLQ_Call) Return(_a0 error) *MockStore_RemoveDLQ_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_RemoveDLQ_Call) RunAndReturn(run func(context.Context, string) error) *MockStore_RemoveDLQ_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
